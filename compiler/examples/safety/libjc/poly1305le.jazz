//-------------------------------------------
// inline of #include "../ref3/poly1305.jazz"
//-------------------------------------------

// assuming little endian for load and store
fn load(reg u64 p) -> reg u64[2]
{
  reg u64[2] x;
  x[0] = [p + 0];
  x[1] = [p + 8];
  return x;
}



fn load_last(reg u64 ptr, reg u64 len) -> reg u64[2]
{
  reg   u64    j;
  reg   u64[2] x;
  stack u64[2] s;
  reg   u8     c;

  s[0] = 0;
  s[1] = 0;

  j = 0;
  while(j < len)
  { c = (u8)[ptr + j];
    s[u8 (int)j] = c;
    j += 1;
  }

  s[u8 (int)j] = 0x1;

  x[0] = s[0];
  x[1] = s[1];

  return x;
}



fn store(reg u64 p, reg u64[3] x)
{
  [p + 0] = x[0];
  [p + 8] = x[1];
}



fn clamp(reg u64 k) -> reg u64[2], reg u64
{
  reg u64[2] r;
  reg u64 r54;
  r = load(k);
  r[0] &= 0x0ffffffc0fffffff;
  r[1] &= 0x0ffffffc0ffffffc;
  r54 = r[1];
  r54 >>= 2;
  r54 += r[1];
  return r, r54; // r54 = r[1] * 5/4;
}



fn add_bit(reg u64[3] h, reg u64[2] m, inline int b) -> reg u64[3]
{
  reg bool cf;
  cf, h[0] += m[0];
  cf, h[1] += m[1] + cf;
   _, h[2] +=    b + cf;
  return h;
}



fn mulmod(reg u64[3] h, reg u64[2] r, reg u64 r54) -> reg u64[3]
{
  reg bool cf;
  reg u64 high low h2rx4 h2r;
  reg u64[3] t;

  low = h[0];
  high, low = low * r[0];
  t[0] = low;
  t[1] = high;

  low = h[1];
  high, low = low * r54;
  cf, t[0] += low;
   _, t[1] += high + cf;

  t[2] = 0;

  low = h[0];
  high, low = low * r[1];
  cf, t[1] += low;
   _, t[2] += high + cf;

  low = h[1];
  high, low = low * r[0];
  cf, t[1] += low;
   _, t[2] += high + cf;

  low = h[2];
  low *= r54;
  cf, t[1] += low;
   _, t[2] += 0 + cf;


  h[2] *= r[0];

  h[0] = t[0];
  h[1] = t[1];
  h[2] += t[2];


  // now we need to reduce h: in h[0] and h[1] we have 128 bits. The first 2
  // bits of h[2] stay in h[2] (to make it 130) and reduce the remaining.
  // Since we are in mod 2**130 - 5 we just need to take all the bits after 130
  // (h[2] >> 2), multiply it by 5 (which is the same as (h[2]>>2)*4 + (h[2]>>2)
  // or (h[2]>>2)<<2 + (h[2]>>2)), add it to the first limb and propagate the carry.

  // for the first call of mulmod:
  //   h[2] = 0x2ffffff4_2ffffffb
  //   (h[2]/4) * 5 = 0x3bfffff1_3bfffff9 (62 bits are required)
  //
  // for the second and subsequent calls to mulmod
  //   h[2] = 0x5fffffe8_5ffffff8
  //   (h[2]/4) * 5 = 0x77ffffe2_77fffff6 (63 bits are required)

  h2r = h[2];
  h2rx4 = h[2];
  h[2] &= 3; // clear the remaining bits
  h2r >>= 2; // (h[2]>>2)
  h2rx4 &= -4; // clear first 2 bits: (h[2]>>2)<<2
  h2r += h2rx4;

  cf, h[0] += h2r;
  cf, h[1] += 0 + cf;
   _, h[2] += 0 + cf;

  // question: how many bits have h[2] after the last full carry propagation, 2 or 3?
  // - if it has 2 bits the maximum value of is
  //    h <= 2**0 * (2**64 -1)  +  2**64 * (2**64 -1) + 2**128 * (2**2 -1)
  // - if it has 3 bits it means that all bits of h[1] and the first 2 bits of h[2] are
  //   zero, so the maximum value of h[2] is 100b which is 4 (but we could just assume, for
  //   the simplicity of the proof, that h[1] can have a value different than 0)

  // main observation: there could be only one bit set after the first two of h[2], and
  // h[2] can be 0, 1, 2, 3 or 4.
  return h;
}



fn freeze(reg u64[3] h) -> reg u64[3]
{
  reg bool cf;
  reg u64[3] g;
  reg u64 mask;

  g = h;

  // if h[2] value is <= 4 then g[2] can be at most 5 (101b)
  cf, g[0] += 5;
  cf, g[1] += 0 + cf;
   _, g[2] += 0 + cf;

  // which means that by shifting right by 2 we are left with only 1 bit set
  g[2] >>= 2;

  // and if this bit is set g[2]: mask will be 2**64-1 (all bits are set) otherwise
  // the mask will be zero
  mask = -g[2];

  g[0] ^= h[0];
  g[1] ^= h[1];

  g[0] &= mask;
  g[1] &= mask;

  // if bit == 1 then h[0..1] ^= (g[0..1] ^ h[0..1])
  // else             h[0..1] ^= 0
  h[0] ^= g[0];
  h[1] ^= g[1];

  // at this point we only need the first 128 bits
  return h;
}



fn setup(reg u64 k) -> reg u64[3], reg u64[2], reg u64, reg u64
{
  inline int i;
  reg u64[3] h;
  reg u64[2] r;
  reg u64 len r54;

  for i=0 to 3 { h[i] = 0; }
  r, r54 = clamp(k);
  k += 16;
  return h, r, r54, k;
}



fn update(reg u64 in, reg u64 inlen, reg u64[3] h, reg u64[2] r, reg u64 r54) -> reg u64, reg u64, reg u64[3]
{
  reg u64[2] m;

  while(inlen >= 16)
  { m = load(in);
    h = add_bit(h, m, 1);
    h = mulmod(h, r, r54);
    in += 16;
    inlen -= 16;
  }

  return in, inlen, h;
}



fn last(reg u64 out, reg u64 in, reg u64 inlen, reg u64 k, reg u64[3] h, reg u64[2] r, reg u64 r54)
{
  reg u64[2] m, s;

  if(inlen > 0)
  { m = load_last(in, inlen);
    h = add_bit(h, m, 0); // load last already sets the last bit
    h = mulmod(h, r, r54);
  }

  h = freeze(h);
  s = load(k);
  h = add_bit(h, s, 0);

  store(out, h);
}


export
fn poly1305_ref3_local(reg u64 out, reg u64 in, reg u64 len, reg u64 k)
{
  reg u64[3] h;
  reg u64[2] r;
  reg u64 r54;
  if(len < 257){
    h, r, r54, k = setup(k);
    in, len, h = update(in, len, h, r, r54);
    last(out, in, len, k, h, r, r54);
  }
}
